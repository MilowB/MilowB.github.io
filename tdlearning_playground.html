<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>REINFORCEjs: Gridworld with Dynamic Programming</title>
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- jquery and jqueryui -->
	<script src="assets/external/jquery-2.1.3.min.js"></script>
	<link href="assets/external/jquery-ui.min.css" rel="stylesheet">
	<script src="assets/external/jquery-ui.min.js"></script>

	<!-- bootstrap -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
	<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet">


	<!-- d3js -->
	<script src="https://d3js.org/d3.v6.min.js"></script>
	<!-- markdown -->
	<script type="text/javascript" src="assets/external/marked.js"></script>
	<script type="text/javascript" src="assets/external/highlight.pack.js"></script>
	<link rel="stylesheet" href="assets/external/highlight_default.css">
	<script>hljs.initHighlightingOnLoad();</script>

	<!-- mathjax : nvm now loading dynamically
  <script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
-->

	<!-- rljs -->
	<script type="text/javascript" src="assets/lib/rl.js"></script>

	<!-- flotjs -->
	<script src="assets/external/jquery.flot.min.js"></script>

	<!-- mathjax -->
	<script>
		window.MathJax = {
			tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
			svg: { fontCache: 'global' }
		};
	</script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

	<style>
		#wrap {
			width: 100%;
			margin-left: auto;
			margin-right: auto;
			padding-top: 35px;
			padding-bottom: 35px;
		}

		#wrapWhite {
			width: 100%;
			margin-left: auto;
			margin-right: auto;
			margin-top: 20px;
			margin-bottom: 20px;
			padding-top: 35px;
			padding-bottom: 35px;
		}

		#wrapGrey {
			width: 100%;
			margin-left: auto;
			margin-right: auto;
			background-color: #F7F7F7;
			margin-top: 20px;
			margin-bottom: 20px;
			padding-top: 35px;
			padding-bottom: 35px;
			border-top: solid;
			border-bottom: solid;
			border-color: #DDDDDD;
		}

		#wrapTight {
			width: 1000px;
			margin-left: auto;
			margin-right: auto;
		}

		body {
			font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
		}

		#draw {
			margin-left: 100px;
		}

		#exp {
			margin-top: 20px;
			font-size: 16px;
		}

		h2 {
			text-align: center;
			font-size: 30px;
		}

		svg {
			cursor: pointer;
		}
	</style>

	<script type="application/javascript">

		// Gridworld
		var Gridworld = function () {
			this.Rarr = null; // reward array
			this.T = null; // cell types, 0 = normal, 1 = cliff
			switchEasyMode();

			this.reset()
		}
		Gridworld.prototype = {
			reset: function () {

				// hardcoding one gridworld for now
				this.gh = 5;
				this.gw = 6;
				this.gs = this.gh * this.gw; // number of states
				this.finalState = 23;
				this.minReward = 0;
				this.maxReward = 0;
				// specify some rewards
				var Rarr = R.zeros(this.gs);
				var T = R.zeros(this.gs);
				Rarr[this.finalState] = 1.5;
				Rarr[14] = -0.5;

				T[4] = 1;
				T[7] = 1;
				T[5] = 1;
				T[8] = 1;
				T[16] = 1;
				T[18] = 1;
				T[22] = 1;
				T[25] = 1;
				T[29] = 1;

				this.Rarr = Rarr;
				this.T = T;
			},
			reward: function (s, a, ns) {
				// reward of being in s, taking action a, and ending up in ns
				return this.Rarr[s];
			},
			nextStateDistribution: function (s, a) {
				// given (s,a) return distribution over s' (in sparse form)
				if (this.T[s] === 1) {
					// cliff! oh no!
					// var ns = 0; // reset to state zero (start)
				} else if (s === this.finalState) {
					// agent wins! teleport to start
					var ns = this.startState();
					while (this.T[ns] === 1) {
						var ns = this.randomState();
					}
				} else {
					// ordinary space
					var nx, ny;
					var x = this.stox(s);
					var y = this.stoy(s);
					if (a === 0) { nx = x - 1; ny = y; }
					if (a === 1) { nx = x; ny = y - 1; }
					if (a === 2) { nx = x; ny = y + 1; }
					if (a === 3) { nx = x + 1; ny = y; }
					var ns = nx * this.gh + ny;
					if (this.T[ns] === 1) {
						// actually never mind, this is a wall. reset the agent
						var ns = s;
					}
				}
				// gridworld is deterministic, so return only a single next state
				return ns;
			},
			updateRewards: function () {
				for (var s = 0; s < this.Rarr.length; s++) {
					if (this.Rarr[s] > this.maxReward) {
						this.maxReward = this.Rarr[s];
					}
					if (this.Rarr[s] < this.minReward) {
						this.minReward = this.Rarr[s];
					}
				}
				minRew = this.minReward;
				maxRew = this.maxReward;
			},
			sampleNextState: function (s, a) {
				// gridworld is deterministic, so this is easy
				var ns = this.nextStateDistribution(s, a);
				var r = this.Rarr[ns]; // observe the raw reward of being in s, taking a, and ending up in ns
				r -= 0.01; // every step takes a bit of negative reward
				var out = { 'ns': ns, 'r': r };
				if (s === this.finalState && ns === 0) {
					// episode is over
					out.reset_episode = true;
				}
				return out;
			},
			allowedActions: function (s) {
				var x = this.stox(s);
				var y = this.stoy(s);
				var as = [];
				if (x > 0) { as.push(0); }
				if (y > 0) { as.push(1); }
				if (y < this.gh - 1) { as.push(2); }
				if (x < this.gw - 1) { as.push(3); }
				return as;
			},
			randomState: function () { return Math.floor(Math.random() * this.gs); },
			startState: function () { return 0; },
			getNumStates: function () { return this.gs; },
			getMaxNumActions: function () { return 4; },

			// private functions
			stox: function (s) { return Math.floor(s / this.gh); },
			stoy: function (s) { return s % this.gh; },
			xytos: function (x, y) { return x * this.gh + y; },
		}

		// ------
		// UI
		// ------
		var rs = {};
		var trs = {};
		var tvs = {};
		var pas = {};
		var previousObs = undefined;
		var cs = 60;  // cell size
		var barchart = false;
		var selectedCell = -1;
		var spec = {};
		spec["gamma"] = 0.9; // discount factor, [0, 1)
		spec["epsilon"] = 0.2; // initial epsilon for epsilon-greedy policy, [0, 1)
		spec["alpha"] = 0.1; // value function learning rate
		spec["lambda"] = 0; // eligibility trace decay, [0,1). 0 = no eligibility traces
		spec["beta"] = 0.1; // learning rate for smooth policy update
		var currentQvalue = 0;
		var currentAction = 0;
		var nextStateReward = 0;
		var nextBestActionQvalue = 0;
		var equation = false;
		// 0 = easy
		// 1 = intermediate
		// 2 = advanced
		var mode = 0;

		var initGrid = function () {

			updateEquation(false);
			$("#advancedModeHTML").hide();
			$(".qvaluescharts").hide();
			$("#rewardui").hide();
			var d3elt = d3.select('#draw');
			d3elt.html('');
			rs = {};
			trs = {};
			tvs = {};
			pas = {};

			var gh = env.gh; // height in cells
			var gw = env.gw; // width in cells
			var gs = env.gs; // total number of cells

			var w = 600;
			var h = 300;
			svg = d3elt.append('svg').attr('width', w).attr('height', h)
				.append('g').attr('transform', 'scale(1)');

			// define a marker for drawing arrowheads
			svg.append("defs").append("marker")
				.attr("id", "arrowhead")
				.attr("refX", 3)
				.attr("refY", 2)
				.attr("markerWidth", 3)
				.attr("markerHeight", 4)
				.attr("orient", "auto")
				.append("path")
				.attr("d", "M 0,0 V 4 L3,2 Z");

			for (var y = 0; y < gh; y++) {
				for (var x = 0; x < gw; x++) {
					var xcoord = x * cs;
					var ycoord = y * cs;
					var s = env.xytos(x, y);

					var g = svg.append('g');
					// click callbackfor group
					g.on('click', function (ss) {
						return function () { cellClicked(ss); } // close over s
					}(s));

					// set up cell rectangles
					var r = g.append('rect')
						.attr('x', xcoord)
						.attr('y', ycoord)
						.attr('s', s)
						.attr('height', cs)
						.attr('width', cs)
						.attr('fill', '#86847A')
						.attr('stroke', '#DEDEDE')
						.attr('stroke-width', 2);
					rs[s] = r;

					// Affichage de l'image sur une case spécifique (ex: en haut à gauche)
					/*if (x === 0 && y === 0) {
						g.append('image')
							.attr('x', xcoord)
							.attr('y', ycoord)
							.attr('width', cs)
							.attr('height', cs)
							.attr('href', 'images/fire.svg'); // Remplace par l'URL de ton image
					}*/

					// reward text
					var tr = g.append('text')
						.attr('x', xcoord + 5)
						.attr('y', ycoord + 55)
						.attr('s', s)
						.attr('font-size', 10)
						.text('');
					trs[s] = tr;

					// skip rest for cliffs
					if (env.T[s] === 1) { continue; }

					// value text
					var tv = g.append('text')
						.attr('x', xcoord + 5)
						.attr('y', ycoord + 20)
						.text('');
					tvs[s] = tv;

					// policy arrows
					pas[s] = []
					for (var a = 0; a < 4; a++) {
						var pa = g.append('line')
							.attr('x1', xcoord)
							.attr('y1', ycoord)
							.attr('x2', xcoord)
							.attr('y2', ycoord)
							.attr('stroke', 'black')
							.attr('stroke-width', '2')
							.attr("marker-end", "url(#arrowhead)");
						pas[s].push(pa);
					}
				}
			}

			// append agent position circle
			svg.append('circle')
				.attr('cx', -100)
				.attr('cy', -100)
				.attr('r', 15)
				.attr('fill', '#327BB5')
				.attr('stroke', '#000')
				.attr('id', 'cpos');
			//.attr('href', 'images/fire.svg');

		}

		function showBarChart(actionValues, svg, gridSize) {
			if (barchart) {
				var chartWidth = 200;  // Largeur de la zone du bar chart
				var chartHeight = (gridSize) * 50;  // Ajusté à la hauteur de la grille
				var margin = { top: 20, right: 20, bottom: 40, left: 50 };

				// Positionnement du graphique
				var chartX = gridSize * 50 + 150;
				var chartY = 10;

				// Supprime l'ancien graphique s'il existe
				svg.selectAll(".bar-chart-group").remove();

				// Création du groupe principal
				var chartGroup = svg.append("g")
					.attr("class", "bar-chart-group")
					.attr("transform", `translate(${chartX}, ${chartY})`);

				// Transformation des données en tableau
				var data = Object.keys(actionValues).map(action => ({
					action: action,
					value: actionValues[action]
				}));

				// Détermination des bornes pour gérer les valeurs négatives
				var minValue = d3.min(data, d => d.value);
				var maxValue = d3.max(data, d => d.value);

				// Création des échelles
				var x = d3.scaleBand()
					.domain(data.map(d => d.action))
					.range([0, chartWidth])
					.padding(0.2);

				var y = d3.scaleLinear()
					.domain([Math.min(0, minValue), Math.max(0, maxValue)]) // S'assure d'inclure 0
					.range([chartHeight - margin.bottom, margin.top]);

				var zeroY = y(0); // Position verticale de l'axe zéro

				// Ajout des barres
				chartGroup.selectAll("rect")
					.data(data)
					.enter()
					.append("rect")
					.attr("x", d => x(d.action))
					.attr("y", d => d.value >= 0 ? y(d.value) : zeroY) // Position en fonction du signe
					.attr("width", x.bandwidth())
					.attr("height", d => Math.abs(y(d.value) - zeroY)) // Hauteur proportionnelle
					.attr("fill", d => d.value >= 0 ? "steelblue" : "tomato"); // Couleur différente pour les négatifs

				// Ajout d'une ligne horizontale pour l'axe 0
				chartGroup.append("line")
					.attr("x1", 0)
					.attr("x2", chartWidth)
					.attr("y1", zeroY)
					.attr("y2", zeroY)
					.attr("stroke", "black")
					.attr("stroke-width", 1);

				// Ajout des labels de valeurs sur les barres
				chartGroup.selectAll("text.value-label")
					.data(data)
					.enter()
					.append("text")
					.attr("class", "value-label")
					.attr("x", d => x(d.action) + x.bandwidth() / 2)
					.attr("y", d => d.value >= 0 ? y(d.value) - 5 : y(d.value) + 15) // Ajustement selon le signe
					.attr("text-anchor", "middle")
					.attr("font-size", "13px")
					.attr("fill", "black")
					.text(d => d.value.toFixed(2));

				// Ajout des axes
				chartGroup.append("g")
					.attr("transform", `translate(0,${zeroY})`) // Position ajustée
					.call(d3.axisBottom(x));

				chartGroup.append("g")
					.call(d3.axisLeft(y));

			}
			else {
				svg.selectAll(".bar-chart-group").remove();
			}
		}

		function intToArrow(val) {
			// 0 gauche
			// 1 haut
			// 2 bas
			// 3 droite
			switch (val) {
				case 1: return "Haut";
				case 2: return "Bas";
				case 0: return "Gauche";
				case 3: return "Droite";
				default: return "?";
			}
		}

		var drawGrid = function () {
			var gh = env.gh; // height in cells
			var gw = env.gw; // width in cells
			var gs = env.gs; // total number of cells

			var sx = env.stox(state);
			var sy = env.stoy(state);
			d3.select('#cpos')
				.attr('cx', sx * cs + cs / 2)
				.attr('cy', sy * cs + cs / 2);

			// updates the grid with current state of world/agent
			for (var y = 0; y < gh; y++) {
				for (var x = 0; x < gw; x++) {
					var xcoord = x * cs;
					var ycoord = y * cs;
					var r = 255, g = 255, b = 255;
					var s = env.xytos(x, y);

					d3.select('svg')
						.selectAll('image') // Sélectionner toutes les images
						.filter(function () {
							// Vérifier si l'image est déjà associée à cet état terminal
							var imageS = d3.select(this).attr('s');
							return imageS == s; // Comparer les coordonnées
						})
						.remove();
					// Ajouter une image sur certaines cases (exemple : les états terminaux ou obstacles)
					if (env.Rarr[s] < 0) {
						var ratio = env.Rarr[s] * -0.8;

						d3.select('svg')
							.append('image')
							.attr('x', xcoord)
							.attr('y', ycoord)
							.attr('s', s)
							.attr('width', cs)
							.attr('height', cs)
							.attr('href', 'images/fire.svg')
							.style('pointer-events', 'none') // Empêche l'image d'interférer avec les clics$
							.attr('opacity', '0.75');
					}
					else if (s == env.finalState) {
						d3.select('svg')
							.append('image')
							.attr('x', xcoord)
							.attr('y', ycoord)
							.attr('s', s)
							.attr('width', cs)
							.attr('height', cs)
							.attr('href', 'images/gem.svg')
							.style('pointer-events', 'none') // Empêche l'image d'interférer avec les clics$
							.attr('opacity', '0.75');
					}

					// get value of state s under agent policy
					if (typeof agent.V !== 'undefined') {
						var vv = agent.V[s];
					} else if (typeof agent.Q !== 'undefined') {
						var poss = env.allowedActions(s);
						var vv = -1;
						// get the max qvalue of every actions in that state
						for (var i = 0, n = poss.length; i < n; i++) {
							var qsa = agent.Q[poss[i] * gs + s];
							if (i === 0 || qsa > vv) { vv = qsa; }
						}
					}

					var ms = 100;
					if (vv > 0) { g = 255; r = 255 - vv * ms; b = 255 - vv * ms; }
					if (vv < 0) { g = 255 + vv * ms; r = 255; b = 255 + vv * ms; }
					var vcol = 'rgb(' + Math.floor(r) + ',' + Math.floor(g) + ',' + Math.floor(b) + ')';
					if (env.T[s] === 1) { vcol = "#AAA"; rcol = "#AAA"; }

					// update colors of rectangles based on value
					var r = rs[s];
					if (s === selected) {
						// highlight selected cell
						r.attr('fill', '#FF0');
					} else {
						r.attr('fill', vcol);
					}

					// write reward texts
					var rv = env.Rarr[s];
					var tr = trs[s];
					if (rv !== 0) {
						tr.text('R ' + rv.toFixed(1));
					}

					// skip rest for cliff
					if (env.T[s] === 1) continue;

					// write value
					var tv = tvs[s];
					if (s !== env.finalState)
						tv.text(String(Math.round(vv * 100) / 100)); // vv.toFixed(2)

					// update policy arrows
					var paa = pas[s];
					for (var a = 0; a < 4; a++) {
						var pa = paa[a];
						var prob = agent.P[a * gs + s];
						if (prob < 0.01) { pa.attr('visibility', 'hidden'); }
						else { pa.attr('visibility', 'visible'); }
						var ss = cs / 2 * prob * 0.9;
						if (a === 0) { nx = -ss; ny = 0; }
						if (a === 1) { nx = 0; ny = -ss; }
						if (a === 2) { nx = 0; ny = ss; }
						if (a === 3) { nx = ss; ny = 0; }
						pa.attr('x1', xcoord + cs / 2)
							.attr('y1', ycoord + cs / 2)
							.attr('x2', xcoord + cs / 2 + nx)
							.attr('y2', ycoord + cs / 2 + ny);
					}
				}
			}
			if (barchart) {
				var qvalues = {};
				// 0 gauche
				// 1 haut
				// 2 bas
				// 3 droite
				if (typeof agent.Q !== 'undefined') {
					var poss = env.allowedActions(selectedCell);
					var vv = -1;
					// get the max qvalue of every actions in that state
					for (var i = 0, n = poss.length; i < n; i++) {
						var qsa = agent.Q[poss[i] * gs + selectedCell];
						var c = intToArrow(poss[i]);
						qvalues[c] = qsa;
					}
				}
				showBarChart(qvalues, d3.select('svg'), env.gh);
			}
		}

		var selected = -1;
		var cells = []

		var cellClicked = function (s) {
			var gs = env.gs; // total number of cells
			var qvalues = {};
			// 0 gauche
			// 1 haut
			// 2 bas
			// 3 droite
			if (typeof agent.Q !== 'undefined') {
				var poss = env.allowedActions(selectedCell);
				// get the max qvalue of every actions in that state
				for (var i = 0, n = poss.length; i < n; i++) {
					var qsa = agent.Q[poss[i] * gs + selectedCell];
					var c = intToArrow(poss[i]);
					qvalues[c] = qsa;
				}
			}
			if (s === selected && env.T[s] != 1) {
				selected = -1; // toggle off
				barchart = false;
				$("#rewardui").hide("slow", function () { });
				$(".qvaluescharts").hide("slow", function () { });
			} else if (env.T[s] != 1) {
				selected = s;
				selectedCell = s;
				barchart = true;
				$("#creward").html(env.Rarr[s].toFixed(2));
				$("#rewardui").show("slow", function () { });
				if (mode > 0)
					$(".qvaluescharts").show("slow", function () { });
				//$("#rewardslider").slider('value', env.Rarr[s]);
			}
			showBarChart(qvalues, d3.select('svg'), env.gh);
			drawGrid(); // redraw
		}

		var nextStep = function () {
			flag = 1;
			equation = true;
			save_tick = steps_per_tick;
			steps_per_tick = 1;
			$("#startButton").html("Reprendre");
			sid = -1;
			tdlearn();
		}

		var startAgain = function () {
			if (flag === -1) {
				flag = 0;
				sid = 1;
			}
			else {
				for (var i = 0; i < Object.keys(rs).length; i++) {
					rs[i].attr("stroke", "#DEDEDE").attr("stroke-width", "2");
				}
				flag = -1;
				sid = -1;
			}
			tdlearn();
		}

		var steps_per_tick = 20;
		var save_tick = steps_per_tick;
		var flag = 0;
		var sid = -1;
		var nsteps_history = [];
		var nsteps_counter = 0;
		var nflot = 1000;
		var maxRew = 1.5;
		var minRew = 0;
		var previousState = -1;
		var tdlearn = function () {
			if (sid === -1) {
				sid = setInterval(function () {
					env.updateRewards();
					if (flag != 0) {
						if (flag > 0) {
							$("#startButton").html("Reprendre");
							flag -= 1;
						}
						else $("#startButton").html("Pause");
						for (var k = 0; k < steps_per_tick; k++) {
							var a = agent.act(state); // ask agent for an action
							var obs = env.sampleNextState(state, a); // run it through environment dynamics
							currentAction = a; // used for illustration on the equation
							currentQvalue = agent.Q[currentAction * env.gs + state];

							// to avoid processing the qvalues of the last state
							if (previousObs === undefined || !previousObs.reset_episode) {
								agent.learn(obs.r); // allow opportunity for the agent to learn
								nextStateReward = obs.r;

								previousState = state; // keep in mind the previous state
								state = obs.ns; // evolve environment to next state
								previousObs = obs;
								var vv = -1;
								var poss = env.allowedActions(state);
								// get the max qvalue of every actions in that state
								for (var i = 0, n = poss.length; i < n; i++) {
									var qsa = agent.Q[poss[i] * env.gs + state];
									if (i === 0 || qsa > vv) { vv = qsa; }
								}
								nextBestActionQvalue = vv;
								if (equation) {
									updateEquation(true);
									equation = false;
								}
							}
							else {
								previousObs = undefined;
							}
							nsteps_counter += 1;
							if (obs.reset_episode) {
								//----- fill the qvalues in the cells before printing on the plot
								for (var y = 0; y < env.gh; y++) {
									for (var x = 0; x < env.gw; x++) {
										var s = env.xytos(x, y);
										// get value of state s under agent policy
										if (typeof agent.Q !== 'undefined') {
											var poss = env.allowedActions(s);
											if (cells[s] === undefined)
												cells[s] = {}
											for (var i = 0; i < poss.length; i++) {
												if (cells[s][poss[i]] === undefined) {
													cells[s][poss[i]] = [];
												}
												cells[s][poss[i]].push(agent.Q[poss[i] * env.gs + s]);
											}
										}
									}
								}
								agent.resetEpisode();
								if (selectedCell >= 0) {
									if (nsteps_history.length >= nflot) {
										nsteps_history = nsteps_history.slice(1);
									}
									for (var i = 0; i < poss.length; i++) {
										if (selectedCell >= 0 && cells[selectedCell][poss[i]] !== 'undefined' && cells[selectedCell][poss[i]].length >= nflot) {
											var poss = env.allowedActions(selectedCell);
											var size = cells[selectedCell][poss[i]].length;
											cells[selectedCell][poss[i]] = cells[selectedCell][poss[i]].slice(size - nflot, size);
										}
									}
								}
								nsteps_history.push(nsteps_counter);
								nsteps_counter = 0;
							}
						}
					}
					// keep track of reward history
					drawGrid(); // draw
				}, 20);
			} else {
				$("#startButton").html("Reprendre");
				flag = true;
				oneStep = false;
				steps_per_tick = save_tick;
				clearInterval(sid);
				sid = -1;
			}
		}

		function resetAgent() {
			eval($("#agentspec").val())
			agent = new RL.TDAgent(env, spec);
			document.getElementById("slider").value = agent.epsilon;
			document.getElementById("gammaSlider").value = agent.gamma;
			document.getElementById("alphaSlider").value = agent.alpha;
			document.getElementById("speed").value = steps_per_tick / 100;
			$("#spe").html((steps_per_tick / 100).toFixed(2));
			$("#eps").html(Math.round(agent.epsilon * 100) / 100);
			$("#gamma").html(Math.round(agent.gamma * 100) / 100);
			$("#alpha").html(Math.round(agent.alpha * 100) / 100);

			state = env.startState(); // move state to beginning too
			drawGrid();
			updateEquation(false);
			for (var i = 0; i < Object.keys(rs).length; i++) {
				rs[i].attr("stroke", "#DEDEDE").attr("stroke-width", "2");
			}
		}

		function resetParameters() {
			agent.epsilon = 0.20
			agent.gamma = 0.90
			agent.alpha = 0.10
			/*
			$("#slider").slider('value', agent.epsilon);
			$("#gammaSlider").slider('value', agent.gamma);
			$("#alphaSlider").slider('value', agent.alpha);
			*/
			document.getElementById("slider").value = agent.epsilon;
			document.getElementById("gammaSlider").value = agent.gamma;
			document.getElementById("alphaSlider").value = agent.alpha;
			$("#eps").html(agent.epsilon.toFixed(2));
			$("#gamma").html(agent.gamma.toFixed(2));
			$("#alpha").html(agent.epsilon.toFixed(2));
			updateEquation(false);
		}

		function resetAll() {
			env.reset();
			agent.reset();
			drawGrid();
		}

		function initGraph() {
			var container = $("#flotreward");
			var containerQvaluesHaut = $("#flotqvalueshaut");
			var containerQvaluesBas = $("#flotqvaluesbas");
			var containerQvaluesGauche = $("#flotqvaluesgauche");
			var containerQvaluesDroite = $("#flotqvaluesdroite");
			var res = getFlotRewards();
			// 0 gauche
			// 1 haut
			// 2 bas
			// 3 droite
			var resQvaluesHaut = getflotqvalues(1);
			var resQvaluesBas = getflotqvalues(2);
			var resQvaluesGauche = getflotqvalues(0);
			var resQvaluesDroite = getflotqvalues(3);

			series = [{
				data: res,
				lines: { fill: true }
			}];
			var plot = $.plot(container, series, {
				grid: {
					borderWidth: 1,
					minBorderMargin: 20,
					labelMargin: 10,
					backgroundColor: {
						colors: ["#FFF", "#e4f4f4"]
					},
					margin: {
						top: 10,
						bottom: 10,
						left: 10,
					}
				},
				xaxis: {
					min: 0,
					max: nflot
				},
				yaxis: {
					min: 0,
					max: 500
				}
			});
			resQvaluesHaut = [{
				data: resQvaluesHaut,
				lines: { fill: true }
			}];
			resQvaluesBas = [{
				data: resQvaluesBas,
				lines: { fill: true }
			}];
			resQvaluesGauche = [{
				data: resQvaluesGauche,
				lines: { fill: true }
			}];
			resQvaluesDroite = [{
				data: resQvaluesDroite,
				lines: { fill: true }
			}];

			var options = {
				grid: {
					borderWidth: 1,
					minBorderMargin: 20,
					labelMargin: 10,
					backgroundColor: {
						colors: ["#FFF", "#e4f4f4"]
					},
					margin: {
						top: 10,
						bottom: 10,
						left: 10,
					}
				},
				xaxis: {
					min: 0,
					max: nflot
				},
				yaxis: {
					min: 0,
					max: 10
				}
			};
			var plotQvaluesHaut = $.plot(containerQvaluesHaut, resQvaluesHaut, options);
			var plotQvaluesBas = $.plot(containerQvaluesBas, resQvaluesBas, options);
			var plotQvaluesGauche = $.plot(containerQvaluesGauche, resQvaluesGauche, options);
			var plotQvaluesDroite = $.plot(containerQvaluesDroite, resQvaluesDroite, options);
			setInterval(function () {
				// 0 gauche
				// 1 haut
				// 2 bas
				// 3 droite
				resQvaluesHaut[0].data = getflotqvalues(1);
				resQvaluesBas[0].data = getflotqvalues(2);
				resQvaluesGauche[0].data = getflotqvalues(0);
				resQvaluesDroite[0].data = getflotqvalues(3);

				plotQvaluesHaut.setData(resQvaluesHaut);
				plotQvaluesBas.setData(resQvaluesBas);
				plotQvaluesGauche.setData(resQvaluesGauche);
				plotQvaluesDroite.setData(resQvaluesDroite);

				options.yaxis.max = Math.pow(maxRew + 1, 2);
				options.yaxis.min = Math.min(0, (minRew - 1) * 2);

				plotQvaluesHaut = $.plot(containerQvaluesHaut, resQvaluesHaut, options);
				plotQvaluesBas = $.plot(containerQvaluesBas, resQvaluesBas, options);
				plotQvaluesGauche = $.plot(containerQvaluesGauche, resQvaluesGauche, options);
				plotQvaluesDroite = $.plot(containerQvaluesDroite, resQvaluesDroite, options);

				plotQvaluesHaut.draw();
				plotQvaluesBas.draw();
				plotQvaluesGauche.draw();
				plotQvaluesDroite.draw();

				series[0].data = getFlotRewards();
				plot.setData(series);
				plot.draw();
			}, 100);
		}
		function getFlotRewards() {
			// zip rewards into flot data
			var res = [];
			for (var i = 0, n = nsteps_history.length; i < n; i++) {
				res.push([i, nsteps_history[i]]);
			}
			return res;
		}
		function getflotqvalues(direction) {
			// zip rewards into flot data
			var res = [];
			if (selectedCell >= 0 && cells[selectedCell] !== undefined) {
				var actions = Object.keys(cells[selectedCell]);
				var action = String(actions.find(function (value) {
					return value == String(direction);
				}));
				if (action >= 0) {
					for (var i = 0, n = cells[selectedCell][action].length; i < n; i++) {
						res.push([i, cells[selectedCell][action][i]]);
					}
				}
			}
			return res;
		}

		var state;
		var agent, env;
		function start() {
			env = new Gridworld(); // create environment
			state = env.startState();
			eval($("#agentspec").val())
			agent = new RL.TDAgent(env, spec);

			document.querySelector('#slider')
				.addEventListener('input', evt => {
					onChangeRangeSlider(evt.target.value);
				});

			document.querySelector('#gammaSlider')
				.addEventListener('input', evt => {
					onChangeRangeGamma(evt.target.value);
				});

			document.querySelector('#alphaSlider')
				.addEventListener('input', evt => {
					onChangeRangeAlpha(evt.target.value);
				});

			document.querySelector('#speed')
				.addEventListener('input', evt => {
					onChangeRangeSpeed(evt.target.value);
				});

			document.querySelector('#rewardslider')
				.addEventListener('input', evt => {
					onChangeRangeReward(evt.target.value);
				});

			$("#eps").html(agent.epsilon.toFixed(2));

			// render markdown
			$(".md").each(function () {
				$(this).html(marked($(this).html()));
			});

			initGrid();
			drawGrid();
			initGraph();
		}

		function onChangeRangeSlider(value) {
			agent.epsilon = value;
			$("#eps").html(Math.round(value * 100) / 100);
		}

		function onChangeRangeGamma(value) {
			agent.gamma = value;
			$("#gamma").html(Math.round(value * 100) / 100);
			updateEquation(false);
		}

		function onChangeRangeAlpha(value) {
			agent.alpha = value;
			$("#alpha").html(Math.round(value * 100) / 100);
			updateEquation(false);
		}

		function onChangeRangeSpeed(value) {
			steps_per_tick = value * 100;
			save_tick = steps_per_tick;
			$("#spe").html(Math.round(value * 100) / 100);
		}

		function onChangeRangeReward(value) {
			if (selected >= 0) {
				var slider = value;
				env.Rarr[selected] = value;
				$("#creward").html(Math.round(value * 100) / 100);
				drawGrid();
			}
		}

		function updateEquation(updateColors) {
			let equationEl = document.getElementById("equation");
			var operation = Math.round((currentQvalue + agent.alpha * (nextStateReward + agent.gamma * nextBestActionQvalue - currentQvalue)) * 100) / 100;

			currentQvalue = Math.round(currentQvalue * 100) / 100;
			nextStateReward = Math.round(nextStateReward * 100) / 100;
			nextBestActionQvalue = Math.round(nextBestActionQvalue * 100) / 100;

			equationEl.innerHTML = `\\( ${operation} \\hspace{1cm} = \\hspace{1cm} \\textcolor{blueviolet}{${currentQvalue}} \\hspace{1cm} + 
			\\textcolor{orange}{${agent.alpha}} \\times [ \ \\textcolor{teal}{${nextStateReward}} \\hspace{0.5cm} + 
			\\textcolor{purple}{${agent.gamma}} \\times \\hspace{1.3cm} \\textcolor{blue}{${nextBestActionQvalue}} \\hspace{1.3cm} - 
			\\textcolor{blueviolet}{${currentQvalue}} ] \ \\)`;

			// Reset colors
			for (var i = 0; i < Object.keys(rs).length; i++) {
				rs[i].attr("stroke", "#DEDEDE").attr("stroke-width", "2");
			}
			if (updateColors && previousState >= 0 && mode > 1) {
				rs[previousState].attr("stroke", "#B981EF").attr("stroke-width", "8px");
				rs[state].attr("stroke", "#1900FF").attr("stroke-width", "8px");
			}
			MathJax.typeset();
		}

		function switchEasyMode() {
			mode = 0;
			$("#advancedModeHTML").hide("slow", function () { });
			$("#intermediateModeHTML").hide("slow", function () { });
			document.getElementById("bar1").classList.add("active");
			document.getElementById("bar2").classList.remove("active");
			document.getElementById("bar3").classList.remove("active");
			let modeDescription = document.getElementById("modeDescription");
			modeDescription.innerHTML = "<strong>Mode facile activé.<br>Objectif : </strong> prendre en main le bac à sable avec un nombre de paramètres réduit. Le bouton 'Commencer' lance l'apprentissage. Le bouton 'Exécuter un mouvement' permet d'exécuter les actions une part une. Vous pouvez découvrir l'effet du paramètre 'epsilon' permettant à l'agent d'explorer la grille au lieu d'exécuter l'action prédominante (la flèche). Vous pouvez également cliquer sur une case et observer la valeur de chaque action pour une case donnée. Plus la valeur est haute, plus l'action est intéressante. En cliquant sur une case, vous verrez que vous pouvez modifier la valeur de récompense associée à celle-ci. Une forte récompense incite l'agent à se déplacer sur cette case. Au contraire une récompense négative l'incite à l'éviter.<br><br> Lorsque l'agent (le point bleu) choisi sa prochaine action, il a une probabilité epsilon d'exécuter une action aléatoire à la place. Ce mécanisme lui permet d'explorer des nouvelles cases de la grille qu'il n'aurait pas découvert autrement.";
		}

		function switchIntermediateMode() {
			mode = 1;
			$("#intermediateModeHTML").show("slow", function () { });
			$("#advancedModeHTML").hide("slow", function () { });
			document.getElementById("bar1").classList.remove("active");
			document.getElementById("bar2").classList.add("active");
			document.getElementById("bar3").classList.remove("active");
			let modeDescription = document.getElementById("modeDescription");
			modeDescription.innerHTML = "<strong>Mode intermédiaire activé.<br>Objectif : </strong> découvrir les effets des paramètres alpha et gamma. Jouez avec les valeurs et observez les résultats sur le calcul des valeurs des chaque couple (état, action). Quatre nouveaux graphiques présentant l'historique des valeurs vous permettront de mieux appréhender les changements induits par alpha et gamma. Vous devriez observer qu'Alpha influence la vitesse d'apprentissage alors que gamma influence la portée de la propagation des récompenses dans la grille. Essayez de trouver les meilleurs paramètres vous permettant d'accéder à la case objectif avec le moins d'étapes possible.";
		}

		function switchAdvancedMode() {
			mode = 2;
			$("#intermediateModeHTML").show("slow", function () { });
			$("#advancedModeHTML").show("slow", function () { });
			document.getElementById("bar1").classList.remove("active");
			document.getElementById("bar2").classList.remove("active");
			document.getElementById("bar3").classList.add("active");
			let modeDescription = document.getElementById("modeDescription");
			modeDescription.innerHTML = "<strong>Mode avancé activé.<br>Objectif : </strong> vous découvrez maintenant l'équation permettant de mettre à jour les valeurs de la grille. Vous pouvez voir étape par étape le calcul effectué avec les nombres de la grille en cliquant sur 'Exécuter un mouvement'. Vous devriez mieux comprendre pourquoi les valeurs des actions convergent et de quelle manière leur convergence peut être accélérée par alpha ou comment la portée des récompenses peut être réduite par gamma.";
		}
	</script>
	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
</head>

<body onload="start();">

	<!-- Page Content -->

	<div class="w3-teal container" id="wrap">
		<div id="wrapTight">
			<!--<button class="w3-button w3-teal w3-xlarge" onclick="w3_open()">---- ☰ Tutoriel <---------- </button>-->
					<div class="w3-container">
						<h1 style="text-align: center;">Temporal Difference QLearning Playground</h1>
					</div>
		</div>
	</div>

	<div class="container" id="wrapWhite" style="margin-top: 50px;">
		<div id="wrapTight">
			<div class="row" style="text-align: center; padding:10px;">
				<div class="col-sm-12">
					<ul class="nav nav-tabs">
						<li role="presentation" id="bar1" class="active" onclick="switchEasyMode()"><a href="#bar1">Mode
								facile</a></li>
						<li role="presentation" id="bar2" onclick="switchIntermediateMode()"><a href="#bar1">Mode
								intermédiaire</a></li>
						<li role="presentation" id="bar3" onclick="switchAdvancedMode()"><a href="#bar1">Mode avancé</a>
						</li>
					</ul>
				</div>
				<p id="modeDescription" style="font-size: 16px; margin-top: 15px;"></p>
			</div>
		</div>
	</div>

	<div class="container" id="wrapGrey" style="margin-top: 50px;">
		<div id="wrapTight">
			<div class="row" style="text-align: center; margin-top: 25px; margin-bottom: 25px; padding:10px;">
				<div class="row" style="text-align: center; margin-top: 25px;">
					<div class="col-sm-6">
						<button id="startButton" class="btn btn-primary" onclick="startAgain()"
							style="width:150px;height:50px;margin-bottom:5px;">Commencer</button>
					</div>
					<div class="col-sm-6">
						<button class="btn btn-success" onclick="nextStep()"
							style="width:200px;height:50px;margin-bottom:5px;">Exécuter un mouvement</button>
					</div>
				</div>
				<br>
				<div class="row">
					<div class="col-sm-6">
						Vitesse de l'expérience : <span id="spe">0.20</span>
						<input id="speed" type="range" min="0" max="1" value="0.20" step="0.01" style="width: 100%;">
					</div>
					<div class="col-sm-6">
						Exploration (epsilon) : <span id="eps">0.20</span>
						<input id="slider" type="range" min="0" max="1" value="0.15" step="0.01" style="width: 100%;">
					</div>
				</div>
			</div>
			<hr />
			<div class="row" style="text-align: center; margin-top: 25px; padding:10px;">
				<div class="row">
					<div class="col-sm-2">
						<button class="btn btn-danger" onclick="resetAgent()"
							style="width:150px;height:50px;margin-bottom:5px;">Reinitialiser agent</button>
					</div>
					<!--<div class="col-sm-6">
					<button class="btn btn-warning" onclick="resetParameters()"
					style="width:200px;height:50px;margin-bottom:5px;">Réinitialiser les paramètres</button>
				</div>-->
					<div class="col-sm-10">
						<div id="draw"></div>
					</div>
				</div>
				<br>
				<div class="row">
					<div class="col-sm-12">
						<div id="rewardui" style="width: 80%; padding-left: 20%;">
							Récompense de la case : <span id="creward"></span>
							<input id="rewardslider" type="range" min="-5" max="5" value="0" step="0.1">
						</div>
					</div>
				</div>
				<hr />
				<div class="row" id="advancedModeHTML">
					<h3>Équation utilisée pour mettre à jour les valeurs :</h3>
					<p style="font-size: 25px;">
						\( Q(s, a) \leftarrow \textcolor{blueviolet}{Q(s, a)} + \textcolor{orange}{\alpha} \times [ \,
						\textcolor{teal}{R_{t+1}} + \textcolor{purple}{\gamma} \times
						\textcolor{blue}{max_{a'}Q(s_{t+1}, a')} - \textcolor{blueviolet}{Q(s, a)} ]
						\, \)</p>
					<p id="equation" style="font-size: 25px;">
						\( Q(s, a) \leftarrow \textcolor{blueviolet}{Q(s, a)} + \textcolor{orange}{\alpha} \times [ \,
						\textcolor{teal}{R_{t+1}} + \textcolor{purple}{\gamma} \times
						\textcolor{blue}{max_{a'}Q(s_{t+1}, a')} - \textcolor{blueviolet}{Q(s, a)} ]
						\, \)</p>
				</div>
				<div class="row" id="intermediateModeHTML">
					<div class="col-sm-6">
						Taux d'apprentissage (alpha) : <span id="alpha">0.10</span>
						<input id="alphaSlider" type="range" min="0" max="1" value="0.10" step="0.01"
							style="width: 100%; text-align: center;">
					</div>
					<div class="col-sm-6">
						Facteur de réduction (gamma) : <span id="gamma">0.9</span>
						<input id="gammaSlider" type="range" min="0" max="1" value="0.90" step="0.01"
							style="width: 100%;">
					</div>
				</div>
			</div>
		</div>
	</div>
	<div class="container" id="wrapWhite" style="margin-top: 50px;">
		<div id="wrapTight">
			<div class="row" style="text-align: center; margin-top: 25px; padding:10px;">
				<div class="row qvaluescharts" style="margin-top: 25px;">
					<h3>Valeurs pour chaque action :</h3>
					<div class="col-sm-6">
						Gauche <div id="flotqvaluesgauche" style="width:400px; height: 150px;"></div>
					</div>
					<div class="col-sm-6">
						Droite <div id="flotqvaluesdroite" style="width:400px; height: 150px;"></div>
					</div>
				</div>
				<div class="row qvaluescharts" style="margin-top: 25px;">
					<div class="col-sm-6">
						Haut <div id="flotqvalueshaut" style="width:400px; height: 150px;"></div>
					</div>
					<div class="col-sm-6">
						Bas <div id="flotqvaluesbas" style="width:400px; height: 150px;"></div>
					</div>
				</div>

				<div class="row" style="margin-top: 25px;">
					<h3>Nombre d'actions pour atteindre l'objectif :</h3>
					<div id="flotreward" style="width:100%; height: 250px;"></div>
				</div>
			</div>
		</div>
	</div>

	<div class="w3-sidebar w3-bar-block w3-border-right"
		style="display:none; width: 28%; position: absolute; top:0px; left:0px" id="mySidebar">
		<button onclick="w3_close()" class="w3-bar-item w3-large">Fermer &times;</button>
		<h2>Bienvenue dans ce bac à sable</h2>
		<p style="font-size: 18px; margin: 15px;">
			Ici vous pourrez expérimenter le QLearning et essayez de changer ses paramètres pour mieux comprendre
			comment il fonctionne. Votre objectif : amener le point bleu (votre agent) en haut à gauche de la grille sur
			sa case
			objectif en bas à droite ! <br>
			<strong>Pour cela, cliquez sur "Commencer" !</strong> <br><br>
			Lorsque la grille devient verte, vous pouvez cliquer sur <strong>"Pause"</strong> et continuez avec le
			bouton <strong>"Exécuter un
				mouvement"</strong> pour voir le point bleu suivre le chemin vers son objectif.
		</p>
	</div>
	<script>
		function w3_open() {
			document.getElementById("mySidebar").style.display = "block";
		}

		function w3_close() {
			document.getElementById("mySidebar").style.display = "none";
		}
	</script>
</body>

</html>